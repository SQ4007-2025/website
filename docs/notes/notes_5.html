<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.30">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>notes_5 – Computing Technology</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../images/favicon.ico" rel="icon">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-de070a7b0ab54f8780927367ac907214.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark-2b3e328b71be8d25427581baeb23079b.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-de070a7b0ab54f8780927367ac907214.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-595e7a736fcf46aa1895a448280c433c.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-dark-e9f3ba5fbee03b112b18b9666ab66a2c.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../site_libs/bootstrap/bootstrap-595e7a736fcf46aa1895a448280c433c.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<meta property="og:title" content="Computing Technology">
<meta property="og:image" content="https://SQ4007-2025.github.io/website/notes/images/week_4/Week4Slide015.png">
<meta property="og:site_name" content="Computing Technology">
<meta property="og:image:height" content="540">
<meta property="og:image:width" content="960">
<meta name="twitter:title" content="Computing Technology">
<meta name="twitter:image" content="https://SQ4007-2025.github.io/website/notes/images/twitter-card.png">
<meta name="twitter:creator" content="@EdHarris9000">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-sidebar docked quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-center sidebar-header">
      <a href="../index.html" class="sidebar-logo-link">
      <img src="../images/logo.png" alt="" class="sidebar-logo py-0 d-lg-inline d-none">
      </a>
      <div class="sidebar-tools-main tools-wide">
    <a href="https://github.com/weharris" title="Course GitHub repo" class="quarto-navigation-tool px-1" aria-label="Course GitHub repo"><i class="bi bi-github"></i></a>
    <a href="https://youtube.com/@TheStatisticsLab" title="YouTube" class="quarto-navigation-tool px-1" aria-label="YouTube"><i class="bi bi-youtube"></i></a>
    <a href="https://discord.gg/dnNTE6xhhu" title="Join our Discord" class="quarto-navigation-tool px-1" aria-label="Join our Discord"><i class="bi bi-discord"></i></a>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Welcome!</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../module-schedule.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Schedule</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../module-syllabus.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Syllabus</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../module-links.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Useful links</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../module-faq.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">FAQ</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#lecture-5-notes" id="toc-lecture-5-notes" class="nav-link active" data-scroll-target="#lecture-5-notes">Lecture 5 Notes</a>
  <ul class="collapse">
  <li><a href="#welcome" id="toc-welcome" class="nav-link" data-scroll-target="#welcome">Welcome!</a></li>
  <li><a href="#pixel-art" id="toc-pixel-art" class="nav-link" data-scroll-target="#pixel-art">Pixel Art</a></li>
  <li><a href="#hexadecimal" id="toc-hexadecimal" class="nav-link" data-scroll-target="#hexadecimal">Hexadecimal</a></li>
  <li><a href="#memory" id="toc-memory" class="nav-link" data-scroll-target="#memory">Memory</a></li>
  <li><a href="#pointers" id="toc-pointers" class="nav-link" data-scroll-target="#pointers">Pointers</a></li>
  <li><a href="#strings" id="toc-strings" class="nav-link" data-scroll-target="#strings">Strings</a></li>
  <li><a href="#pointer-arithmetic" id="toc-pointer-arithmetic" class="nav-link" data-scroll-target="#pointer-arithmetic">Pointer Arithmetic</a></li>
  <li><a href="#string-comparison" id="toc-string-comparison" class="nav-link" data-scroll-target="#string-comparison">String Comparison</a></li>
  <li><a href="#copying-and-malloc" id="toc-copying-and-malloc" class="nav-link" data-scroll-target="#copying-and-malloc">Copying and malloc</a></li>
  <li><a href="#valgrind" id="toc-valgrind" class="nav-link" data-scroll-target="#valgrind">Valgrind</a></li>
  <li><a href="#garbage-values" id="toc-garbage-values" class="nav-link" data-scroll-target="#garbage-values">Garbage Values</a></li>
  <li><a href="#pointer-fun-with-binky" id="toc-pointer-fun-with-binky" class="nav-link" data-scroll-target="#pointer-fun-with-binky">Pointer Fun with Binky</a></li>
  <li><a href="#swapping" id="toc-swapping" class="nav-link" data-scroll-target="#swapping">Swapping</a></li>
  <li><a href="#overflow" id="toc-overflow" class="nav-link" data-scroll-target="#overflow">Overflow</a></li>
  <li><a href="#scanf" id="toc-scanf" class="nav-link" data-scroll-target="#scanf"><code>scanf</code></a></li>
  <li><a href="#file-io" id="toc-file-io" class="nav-link" data-scroll-target="#file-io">File I/O</a></li>
  <li><a href="#summing-up" id="toc-summing-up" class="nav-link" data-scroll-target="#summing-up">Summing Up</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/SQ4007-2025/website/edit/main/notes/notes_5.md" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/SQ4007-2025/website/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>





<section id="lecture-5-notes" class="level1">
<h1>Lecture 5 Notes</h1>
<ul>
<li><a href="#welcome">Welcome!</a></li>
<li><a href="#pixel-art">Pixel Art</a></li>
<li><a href="#hexadecimal">Hexadecimal</a></li>
<li><a href="#memory">Memory</a></li>
<li><a href="#pointers">Pointers</a></li>
<li><a href="#strings">Strings</a></li>
<li><a href="#pointer-arithmetic">Pointer Arithmetic</a></li>
<li><a href="#string-comparison">String Comparison</a></li>
<li><a href="#copying-and-malloc">Copying and malloc</a></li>
<li><a href="#valgrind">Valgrind</a></li>
<li><a href="#garbage-values">Garbage Values</a></li>
<li><a href="#pointer-fun-with-binky">Pointer Fun with Binky</a></li>
<li><a href="#swapping">Swapping</a></li>
<li><a href="#overflow">Overflow</a></li>
<li><a href="#scanf"><code>scanf</code></a></li>
<li><a href="#file-io">File I/O</a></li>
<li><a href="#summing-up">Summing Up</a></li>
</ul>
<section id="welcome" class="level2">
<h2 class="anchored" data-anchor-id="welcome">Welcome!</h2>
<ul>
<li>In previous weeks, we talked about images being made of smaller building blocks called pixels.</li>
<li>Today, we will go into further detail about the zeros and ones that make up these images. In particular, we will be going deeper into the fundamental building blocks that make up files, including images.</li>
<li>Further, we will discuss how to access the underlying data stored in computer memory.</li>
<li>As we begin today, know that the concepts covered in this lecture may take some time to fully <em>click</em>.</li>
</ul>
</section>
<section id="pixel-art" class="level2">
<h2 class="anchored" data-anchor-id="pixel-art">Pixel Art</h2>
<ul>
<li><p>Pixels are squares, individual dots, of color that are arranged on an up-down, left-right grid.</p></li>
<li><p>You can imagine an image as a map of bits, where zeros represent black and ones represent white.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/week_4/Week4Slide015.png" class="img-fluid figure-img"></p>
<figcaption>Zeros and ones being converted to a black and white smiley</figcaption>
</figure>
</div></li>
</ul>
</section>
<section id="hexadecimal" class="level2">
<h2 class="anchored" data-anchor-id="hexadecimal">Hexadecimal</h2>
<ul>
<li><p><em>RGB</em>, or <em>red, green, blue</em>, are numbers that represent the amount of each of these colors. In Adobe Photoshop, you can see these settings as follows:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/week_4/Week4Slide016.png" class="img-fluid figure-img"></p>
<figcaption>A photoshop panel with RGB values and hexadecimal input</figcaption>
</figure>
</div>
<p>Notice how the amount of red, blue, and green changes the color selected.</p></li>
<li><p>You can see from the image above that color is not just represented by three values. At the bottom of the window, there is a special value made up of numbers and characters. <code>255</code> is represented as <code>FF</code>. Why might this be?</p></li>
<li><p><em>Hexadecimal</em> is a system of counting that has 16 counting values. They are as follows:</p>
<pre><code>  0 1 2 3 4 5 6 7 8 9 A B C D E F</code></pre>
<p>Notice that <code>F</code> represents <code>15</code>.</p></li>
<li><p>Hexadecimal is also known as <em>base-16</em>.</p></li>
<li><p>When counting in hexadecimal, each column is a power of 16.</p></li>
<li><p>The number <code>0</code> is represented as <code>00</code>.</p></li>
<li><p>The number <code>1</code> is represented as <code>01</code>.</p></li>
<li><p>The number <code>9</code> is represented by <code>09</code>.</p></li>
<li><p>The number <code>10</code> is represented as <code>0A</code>.</p></li>
<li><p>The number <code>15</code> is represented as <code>0F</code>.</p></li>
<li><p>The number <code>16</code> is represented as <code>10</code>.</p></li>
<li><p>The number <code>255</code> is represented as <code>FF</code>, because 16 x 15 (or <code>F</code>) is 240. Add 15 more to make 255. This is the highest number you can count using a two-digit hexadecimal system.</p></li>
<li><p>Hexadecimal is useful because it can be represented using fewer digits. Hexadecimal allows us to represent information more succinctly.</p></li>
</ul>
</section>
<section id="memory" class="level2">
<h2 class="anchored" data-anchor-id="memory">Memory</h2>
<ul>
<li><p>In weeks past, you may recall our artist rendering of concurrent blocks of memory. Applying hexadecimal numbering to each of these blocks of memory, you can visualize these as follows:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/week_4/Week4Slide065.png" class="img-fluid figure-img"></p>
<figcaption>Blocks of memory numbered in hex</figcaption>
</figure>
</div></li>
<li><p>You can imagine how there may be confusion regarding whether the <code>10</code> block above may represent a location in memory or the value <code>10</code>. Accordingly, by convention, all hexadecimal numbers are often represented with the <code>0x</code> prefix as follows:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/week_4/Week4Slide066.png" class="img-fluid figure-img"></p>
<figcaption>blocks of memory numbered in hex with 0x</figcaption>
</figure>
</div></li>
<li><p>In your terminal window, type <code>code addresses.c</code> and write your code as follows:</p>
<pre><code>// Prints an integer

#include &lt;stdio.h&gt;

int main(void)
{
    int n = 50;
    printf("%i\n", n);
}</code></pre>
<p>Notice how <code>n</code> is stored in memory with the value <code>50</code>.</p></li>
<li><p>You can visualize how this program stores this value as follows:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/week_4/Week4Slide070.png" class="img-fluid figure-img"></p>
<figcaption>the value 50 stored in a memory location with hex</figcaption>
</figure>
</div></li>
</ul>
</section>
<section id="pointers" class="level2">
<h2 class="anchored" data-anchor-id="pointers">Pointers</h2>
<ul>
<li><p>The C language has two powerful operators that relate to memory:</p>
<pre><code>  &amp; Provides the address of something stored in memory.
  * Instructs the compiler to go to a location in memory.</code></pre></li>
<li><p>We can leverage this knowledge by modifying our code as follows:</p>
<pre><code>// Prints an integer's address

#include &lt;stdio.h&gt;

int main(void)
{
    int n = 50;
    printf("%p\n", &amp;n);
}</code></pre>
<p>Notice the <code>%p</code>, which allows us to view the address of a location in memory. <code>&amp;n</code> can be literally translated as “the address of <code>n</code>.” Executing this code will return an address of memory beginning with <code>0x</code>.</p></li>
<li><p>A <em>pointer</em> is a variable that stores the address of something. Most succinctly, a pointer is an address in your computer’s memory.</p></li>
<li><p>Consider the following code:</p>
<pre><code>int n = 50;
int *p = &amp;n;</code></pre>
<p>Notice that <code>p</code> is a pointer that contains the address of an integer <code>n</code>.</p></li>
<li><p>Modify your code as follows:</p>
<pre><code>// Stores and prints an integer's address

#include &lt;stdio.h&gt;

int main(void)
{
    int n = 50;
    int *p = &amp;n;
    printf("%p\n", p);
}</code></pre>
<p>Notice that this code has the same effect as our previous code. We have simply leveraged our new knowledge of the <code>&amp;</code> and <code>*</code> operators.</p></li>
<li><p>To illustrate the use of the <code>*</code> operator, consider the following:</p>
<pre><code>// Stores and prints an integer via its address

#include &lt;stdio.h&gt;

int main(void)
{
    int n = 50;
    int *p = &amp;n;
    printf("%i\n", *p);
}</code></pre>
<p>Notice that the <code>printf</code> line prints the integer at the location of <code>p</code>. <code>int *p</code> creates a pointer whose job is to store the memory address of an integer.</p></li>
<li><p>You can visualize our code as follows:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/week_4/Week4Slide078.png" class="img-fluid figure-img"></p>
<figcaption>Same value of 50 in a memory location with a pointer value stored elsewhere</figcaption>
</figure>
</div>
<p>Notice the pointer seems rather large. Indeed, a pointer is usually stored as an 8-byte value. <code>p</code> is storing the address of the <code>50</code>.</p></li>
<li><p>You can more accurately visualize a pointer as one address that points to another:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/week_4/Week4Slide079.png" class="img-fluid figure-img"></p>
<figcaption>A pointer as an arrow, pointing from one location of memory to another</figcaption>
</figure>
</div></li>
</ul>
</section>
<section id="strings" class="level2">
<h2 class="anchored" data-anchor-id="strings">Strings</h2>
<ul>
<li><p>Now that we have a mental model for pointers, we can peel back a level of simplification that was offered earlier in this course.</p></li>
<li><p>Modify your code as follows:</p>
<pre><code>// Prints a string

#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    string s = "HI!";
    printf("%s\n", s);
}</code></pre>
<p>Notice that a string <code>s</code> is printed.</p></li>
<li><p>Recall that a string is simply an array of characters. For example, <code>string s = "HI!"</code> can be represented as follows:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/week_4/Week4Slide085.png" class="img-fluid figure-img"></p>
<figcaption>The string HI with an exclamation point stored in memory</figcaption>
</figure>
</div></li>
<li><p>However, what is <code>s</code> really? Where is the <code>s</code> stored in memory? As you can imagine, <code>s</code> needs to be stored somewhere. You can visualize the relationship of <code>s</code> to the string as follows:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/week_4/Week4Slide086.png" class="img-fluid figure-img"></p>
<figcaption>Same string HI with a pointer pointing to it</figcaption>
</figure>
</div>
<p>Notice how a pointer called <code>s</code> tells the compiler where the first byte of the string exists in memory.</p></li>
<li><p>Modify your code as follows:</p>
<pre><code>// Prints a string's address as well the addresses of its chars

#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    string s = "HI!";
    printf("%p\n", s);
    printf("%p\n", &amp;s[0]);
    printf("%p\n", &amp;s[1]);
    printf("%p\n", &amp;s[2]);
    printf("%p\n", &amp;s[3]);
}</code></pre>
<p>Notice the above prints the memory locations of each character in the string <code>s</code>. The <code>&amp;</code> symbol is used to show the address of each element of the string. When running this code, notice that elements <code>0</code>, <code>1</code>, <code>2</code>, and <code>3</code> are next to one another in memory.</p></li>
<li><p>Likewise, you can modify your code as follows:</p>
<pre><code>// Declares a string with CS50 Library

#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    string s = "HI!";
    printf("%s\n", s);
}</code></pre>
<p>Notice that this code will present the string that starts at the location of <code>s</code>. This code effectively removes the training wheels of the <code>string</code> data type offered by <code>cs50.h</code>. This is raw C code, without the scaffolding of the cs50 library.</p></li>
<li><p>Taking off the training wheels, you can modify your code again:</p>
<pre><code>// Declares a string without CS50 Library

#include &lt;stdio.h&gt;

int main(void)
{
    char *s = "HI!";
    printf("%s\n", s);
}</code></pre>
<p>Notice that <code>cs50.h</code> is removed. A string is implemented as a <code>char *</code>.</p></li>
<li><p>You can imagine how a string, as a data type, is created.</p></li>
<li><p>Last week, we learned how to create your own data type as a struct.</p></li>
<li><p>The cs50 library includes a struct as follows: <code>typedef char *string</code></p></li>
<li><p>This struct, when using the cs50 library, allows one to use a custom data type called <code>string</code>.</p></li>
</ul>
</section>
<section id="pointer-arithmetic" class="level2">
<h2 class="anchored" data-anchor-id="pointer-arithmetic">Pointer Arithmetic</h2>
<ul>
<li><p>Pointer arithmetic is the ability to do math on locations of memory.</p></li>
<li><p>You can modify your code to print out each memory location in the string as follows:</p>
<pre><code>// Prints a string's chars

#include &lt;stdio.h&gt;

int main(void)
{
    char *s = "HI!";
    printf("%c\n", s[0]);
    printf("%c\n", s[1]);
    printf("%c\n", s[2]);
}</code></pre>
<p>Notice that we are printing each character at the location of <code>s</code>.</p></li>
<li><p>Further, you can modify your code as follows:</p>
<pre><code>// Prints a string's chars via pointer arithmetic

#include &lt;stdio.h&gt;

int main(void)
{
    char *s = "HI!";
    printf("%c\n", *s);
    printf("%c\n", *(s + 1));
    printf("%c\n", *(s + 2));
}</code></pre>
<p>Notice that the first character at the location of <code>s</code> is printed. Then, the character at the location <code>s + 1</code> is printed, and so on.</p></li>
<li><p>Likewise, consider the following:</p>
<pre><code>// Prints substrings via pointer arithmetic

#include &lt;stdio.h&gt;

int main(void)
{
    char *s = "HI!";
    printf("%s\n", s);
    printf("%s\n", s + 1);
    printf("%s\n", s + 2);
}</code></pre>
<p>Notice that this code prints the values stored at various memory locations starting with <code>s</code>.</p></li>
</ul>
</section>
<section id="string-comparison" class="level2">
<h2 class="anchored" data-anchor-id="string-comparison">String Comparison</h2>
<ul>
<li><p>A string of characters is simply an array of characters identified by the location of its first byte.</p></li>
<li><p>Earlier in the course, we considered the comparison of integers. We could represent this in code by typing <code>code compare.c</code> into the terminal window as follows:</p>
<pre><code>// Compares two integers

#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    // Get two integers
    int i = get_int("i: ");
    int j = get_int("j: ");

    // Compare integers
    if (i == j)
    {
        printf("Same\n");
    }
    else
    {
        printf("Different\n");
    }
}</code></pre>
<p>Notice that this code takes two integers from the user and compares them.</p></li>
<li><p>In the case of strings, however, one cannot compare two strings using the <code>==</code> operator.</p></li>
<li><p>Utilizing the <code>==</code> operator in an attempt to compare strings will attempt to compare the memory locations of the strings instead of the characters therein. Accordingly, we recommended the use of <code>strcmp</code>.</p></li>
<li><p>To illustrate this, modify your code as follows:</p>
<pre><code>// Compares two strings' addresses

#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    // Get two strings
    char *s = get_string("s: ");
    char *t = get_string("t: ");

    // Compare strings' addresses
    if (s == t)
    {
        printf("Same\n");
    }
    else
    {
        printf("Different\n");
    }
}</code></pre>
<p>Noticing that typing in <code>HI!</code> for both strings still results in the output of <code>Different</code>.</p></li>
<li><p>Why are these strings seemingly different? You can use the following to visualize why:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/week_4/Week4Slide115.png" class="img-fluid figure-img"></p>
<figcaption>two strings stored separately in memory</figcaption>
</figure>
</div></li>
<li><p>Therefore, the code for <code>compare.c</code> above is actually attempting to see if the memory addresses are different, not the strings themselves.</p></li>
<li><p>Using <code>strcmp</code>, we can correct our code:</p>
<pre><code>// Compares two strings using strcmp

#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    // Get two strings
    char *s = get_string("s: ");
    char *t = get_string("t: ");

    // Compare strings
    if (strcmp(s, t) == 0)
    {
        printf("Same\n");
    }
    else
    {
        printf("Different\n");
    }
}</code></pre>
<p>Notice that <code>strcmp</code> can return <code>0</code> if the strings are the same.</p></li>
<li><p>To further illustrate how these two strings are living in two locations, modify your code as follows:</p>
<pre><code>// Prints two strings

#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    // Get two strings
    char *s = get_string("s: ");
    char *t = get_string("t: ");

    // Print strings
    printf("%s\n", s);
    printf("%s\n", t);
}</code></pre>
<p>Notice how we now have two separate strings stored, likely at two separate locations.</p></li>
<li><p>You can see the locations of these two stored strings with a small modification:</p>
<pre><code>// Prints two strings' addresses

#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    // Get two strings
    char *s = get_string("s: ");
    char *t = get_string("t: ");

    // Print strings' addresses
    printf("%p\n", s);
    printf("%p\n", t);
}</code></pre>
<p>Notice that the <code>%s</code> has been changed to <code>%p</code> in the print statement.</p></li>
</ul>
</section>
<section id="copying-and-malloc" class="level2">
<h2 class="anchored" data-anchor-id="copying-and-malloc">Copying and malloc</h2>
<ul>
<li><p>A common need in programming is to copy one string to another.</p></li>
<li><p>In your terminal window, type <code>code copy.c</code> and write code as follows:</p>
<pre><code>// Capitalizes a string

#include &lt;cs50.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    // Get a string
    string s = get_string("s: ");

    // Copy string's address
    string t = s;

    // Capitalize first letter in string
    t[0] = toupper(t[0]);

    // Print string twice
    printf("s: %s\n", s);
    printf("t: %s\n", t);
}</code></pre>
<p>Notice that <code>string t = s</code> copies the address of <code>s</code> to <code>t</code>. This does not accomplish what we are desiring. The string is not copied – only the address is. Further, notice the inclusion of <code>ctype.h</code>.</p></li>
<li><p>You can visualize the above code as follows:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/week_4/Week4Slide124.png" class="img-fluid figure-img"></p>
<figcaption>two pointers pointing at the same memory location with a string</figcaption>
</figure>
</div>
<p>Notice that <code>s</code> and <code>t</code> are still pointing at the same blocks of memory. This is not an authentic copy of a string. Instead, these are two pointers pointing at the same string.</p></li>
<li><p>Before we address this challenge, it’s important to ensure that we don’t experience a <em>segmentation fault</em> through our code, where we attempt to copy <code>string s</code> to <code>string t</code>, where <code>string t</code> does not exist. We can employ the <code>strlen</code> function as follows to assist with that:</p>
<pre><code>// Capitalizes a string, checking length first

#include &lt;cs50.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    // Get a string
    string s = get_string("s: ");

    // Copy string's address
    string t = s;

    // Capitalize first letter in string
    if (strlen(t) &gt; 0)
    {
        t[0] = toupper(t[0]);
    }

    // Print string twice
    printf("s: %s\n", s);
    printf("t: %s\n", t);
}</code></pre>
<p>Notice that <code>strlen</code> is used to make sure <code>string t</code> exists. If it does not, nothing will be copied.</p></li>
<li><p>To be able to make an authentic copy of the string, we will need to introduce two new building blocks. First, <code>malloc</code> allows you, the programmer, to allocate a block of a specific size of memory. Second, <code>free</code> allows you to tell the compiler to <em>free up</em> that block of memory you previously allocated.</p></li>
<li><p>We can modify our code to create an authentic copy of our string as follows:</p>
<pre><code>// Capitalizes a copy of a string

#include &lt;cs50.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    // Get a string
    char *s = get_string("s: ");

    // Allocate memory for another string
    char *t = malloc(strlen(s) + 1);

    // Copy string into memory, including '\0'
    for (int i = 0; i &lt;= strlen(s); i++)
    {
        t[i] = s[i];
    }

    // Capitalize copy
    t[0] = toupper(t[0]);

    // Print strings
    printf("s: %s\n", s);
    printf("t: %s\n", t);
}</code></pre>
<p>Notice that <code>malloc(strlen(s) + 1)</code> creates a block of memory that is the length of the string <code>s</code> plus one. This allows for the inclusion of the <em>null</em> <code>\0</code> character in our final copied string. Then, the <code>for</code> loop walks through the string <code>s</code> and assigns each value to that same location on the string <code>t</code>.</p></li>
<li><p>It turns out that our code is inefficient. Modify your code as follows:</p>
<pre><code>// Capitalizes a copy of a string, defining n in loop too

#include &lt;cs50.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    // Get a string
    char *s = get_string("s: ");

    // Allocate memory for another string
    char *t = malloc(strlen(s) + 1);

    // Copy string into memory, including '\0'
    for (int i = 0, n = strlen(s); i &lt;= n; i++)
    {
        t[i] = s[i];
    }

    // Capitalize copy
    t[0] = toupper(t[0]);

    // Print strings
    printf("s: %s\n", s);
    printf("t: %s\n", t);
}</code></pre>
<p>Notice that <code>n = strlen(s)</code> is defined now in the left-hand side of the <code>for loop</code>. It’s best not to call unneeded functions in the middle condition of the <code>for</code> loop, as it will run over and over again. When moving <code>n = strlen(s)</code> to the left-hand side, the function <code>strlen</code> only runs once.</p></li>
<li><p>The <code>C</code> Language has a built-in function to copy strings called <code>strcpy</code>. It can be implemented as follows:</p>
<pre><code>// Capitalizes a copy of a string using strcpy

#include &lt;cs50.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    // Get a string
    char *s = get_string("s: ");

    // Allocate memory for another string
    char *t = malloc(strlen(s) + 1);

    // Copy string into memory
    strcpy(t, s);

    // Capitalize copy
    t[0] = toupper(t[0]);

    // Print strings
    printf("s: %s\n", s);
    printf("t: %s\n", t);
}</code></pre>
<p>Notice that <code>strcpy</code> does the same work that our <code>for</code> loop previously did.</p></li>
<li><p>Both <code>get_string</code> and <code>malloc</code> return <code>NULL</code>, a special value in memory, in the event that something goes wrong. You can write code that can check for this <code>NULL</code> condition as follows:</p>
<pre><code>// Capitalizes a copy of a string without memory errors

#include &lt;cs50.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    // Get a string
    char *s = get_string("s: ");
    if (s == NULL)
    {
        return 1;
    }

    // Allocate memory for another string
    char *t = malloc(strlen(s) + 1);
    if (t == NULL)
    {
        return 1;
    }

    // Copy string into memory
    strcpy(t, s);

    // Capitalize copy
    if (strlen(t) &gt; 0)
    {
        t[0] = toupper(t[0]);
    }

    // Print strings
    printf("s: %s\n", s);
    printf("t: %s\n", t);

    // Free memory
    free(t);
    return 0;
}</code></pre>
<p>Notice that if the string obtained is of length <code>0</code> or malloc fails, <code>NULL</code> is returned. Further, notice that <code>free</code> lets the computer know you are done with this block of memory you created via <code>malloc</code>.</p></li>
</ul>
</section>
<section id="valgrind" class="level2">
<h2 class="anchored" data-anchor-id="valgrind">Valgrind</h2>
<ul>
<li><p><em>Valgrind</em> is a tool that can check to see if there are memory-related issues with your programs wherein you utilized <code>malloc</code>. Specifically, it checks to see if you <code>free</code> all the memory you allocated.</p></li>
<li><p>Consider the following code for <code>memory.c</code>:</p>
<pre><code>// Demonstrates memory errors via valgrind

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    int *x = malloc(3 * sizeof(int));
    x[1] = 72;
    x[2] = 73;
    x[3] = 33;
}</code></pre>
<p>Notice that running this program does not cause any errors. While <code>malloc</code> is used to allocate enough memory for an array, the code fails to <code>free</code> that allocated memory.</p></li>
<li><p>If you type <code>make memory</code> followed by <code>valgrind ./memory</code>, you will get a report from valgrind that will report where memory has been lost as a result of your program. One error that valgrind reveals is that we attempted to assign the value of <code>33</code> at the 4th position of the array, where we only allocated an array of size <code>3</code>. Another error is that we never freed <code>x</code>.</p></li>
<li><p>You can modify your code to free the memory of <code>x</code> as follows:</p>
<pre><code>// Demonstrates memory errors via valgrind

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    int *x = malloc(3 * sizeof(int));
    x[1] = 72;
    x[2] = 73;
    x[3] = 33;
    free(x);
}</code></pre>
<p>Notice that running valgrind again now results in no memory leaks.</p></li>
</ul>
</section>
<section id="garbage-values" class="level2">
<h2 class="anchored" data-anchor-id="garbage-values">Garbage Values</h2>
<ul>
<li><p>When you ask the compiler for a block of memory, there is no guarantee that this memory will be empty.</p></li>
<li><p>It’s very possible that the memory you allocated was previously utilized by the computer. Accordingly, you may see <em>junk</em> or <em>garbage values</em>. This is a result of you getting a block of memory but not initializing it. For example, consider the following code for <code>garbage.c</code>:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    int scores[1024];
    for (int i = 0; i &lt; 1024; i++)
    {
        printf("%i\n", scores[i]);
    }
}</code></pre>
<p>Notice that running this code will allocate <code>1024</code> locations in memory for your array, but the <code>for</code> loop will likely show that not all values therein are <code>0</code>. It’s always best practice to be aware of the potential for garbage values when you do not initialize blocks of memory to some other value like zero or otherwise.</p></li>
</ul>
</section>
<section id="pointer-fun-with-binky" class="level2">
<h2 class="anchored" data-anchor-id="pointer-fun-with-binky">Pointer Fun with Binky</h2>
<ul>
<li>We watched a <a href="https://www.youtube.com/watch?v=5VnDaHBi8dM">video from Stanford University</a> that helped us visualize and understand pointers.</li>
</ul>
</section>
<section id="swapping" class="level2">
<h2 class="anchored" data-anchor-id="swapping">Swapping</h2>
<ul>
<li><p>In the real world, a common need in programming is to swap two values. Naturally, it’s hard to swap two variables without a temporary holding space. In practice, you can type <code>code swap.c</code> and write code as follows to see this in action:</p>
<pre><code>// Fails to swap two integers

#include &lt;stdio.h&gt;

void swap(int a, int b);

int main(void)
{
    int x = 1;
    int y = 2;

    printf("x is %i, y is %i\n", x, y);
    swap(x, y);
    printf("x is %i, y is %i\n", x, y);
}

void swap(int a, int b)
{
    int tmp = a;
    a = b;
    b = tmp;
}</code></pre>
<p>Notice that while this code runs, it does not work. The values, even after being sent to the <code>swap</code> function, do not swap. Why?</p></li>
<li><p>When you pass values to a function, you are only providing copies. The <em>scope</em> of <code>x</code> and <code>y</code> is limited to the main function as the code is presently written. That is, the values of <code>x</code> and <code>y</code> created in the curly <code>{}</code> braces of the <code>main</code> function only have the scope of the <code>main</code> function. In our code above, <code>x</code> and <code>y</code> are being passed by <em>value</em>.</p></li>
<li><p>Consider the following image:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/week_4/Week4Slide163.png" class="img-fluid figure-img"></p>
<figcaption>a rectangle with machine code at top followed by globals heap and stack</figcaption>
</figure>
</div>
<p>Notice that <em>global</em> variables, which we have not used in this course, live in one place in memory. Various functions are stored in the <code>stack</code> in another area of memory.</p></li>
<li><p>Now, consider the following image:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/week_4/Week4Slide167.png" class="img-fluid figure-img"></p>
<figcaption>a rectangle with main function at bottom and swap function directly above it</figcaption>
</figure>
</div>
<p>Notice that <code>main</code> and <code>swap</code> have two separate <em>frames</em> or areas of memory. Therefore, we cannot simply pass the values from one function to another to change them.</p></li>
<li><p>Modify your code as follows:</p>
<pre><code>// Swaps two integers using pointers

#include &lt;stdio.h&gt;

void swap(int *a, int *b);

int main(void)
{
    int x = 1;
    int y = 2;

    printf("x is %i, y is %i\n", x, y);
    swap(&amp;x, &amp;y);
    printf("x is %i, y is %i\n", x, y);
}

void swap(int *a, int *b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}</code></pre>
<p>Notice that variables are not passed by <em>value</em> but by <em>reference</em>. That is, the addresses of <code>a</code> and <code>b</code> are provided to the function. Therefore, the <code>swap</code> function can know where to make changes to the actual <code>a</code> and <code>b</code> from the main function.</p></li>
<li><p>You can visualize this as follows:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/week_4/Week4Slide198.png" class="img-fluid figure-img"></p>
<figcaption>a and b stored in main function being passed by reference to the swap function</figcaption>
</figure>
</div></li>
</ul>
</section>
<section id="overflow" class="level2">
<h2 class="anchored" data-anchor-id="overflow">Overflow</h2>
<ul>
<li>A <em>heap overflow</em> is when you overflow the heap, touching areas of memory you are not supposed to.</li>
<li>A <em>stack overflow</em> is when too many functions are called, overflowing the amount of memory available.</li>
<li>Both of these are considered <em>buffer overflows</em>.</li>
</ul>
</section>
<section id="scanf" class="level2">
<h2 class="anchored" data-anchor-id="scanf"><code>scanf</code></h2>
<ul>
<li><p>Functions like <code>get_int</code> to simplify the act of getting input from the user.</p></li>
<li><p><code>scanf</code> is a built-in function that can get user input.</p></li>
<li><p>We can reimplement <code>get_int</code> rather easily using <code>scanf</code> as follows:</p>
<pre><code>// Gets an int from user using scanf

#include &lt;stdio.h&gt;

int main(void)
{
    int n;
    printf("n: ");
    scanf("%i", &amp;n);
    printf("n: %i\n", n);
}</code></pre>
<p>Notice that the value of <code>n</code> is stored at the location of <code>n</code> in the line <code>scanf("%i", &amp;n)</code>.</p></li>
<li><p>However, attempting to reimplement <code>get_string</code> is not easy. Consider the following:</p>
<pre><code>// Dangerously gets a string from user using scanf with array

#include &lt;stdio.h&gt;

int main(void)
{
    char s[4];
    printf("s: ");
    scanf("%s", s);
    printf("s: %s\n", s);
}</code></pre>
<p>Notice that no <code>&amp;</code> is required because strings are special. Still, this program will not function correctly every time it is run. Nowhere in this program do we allocate the amount of memory required for our string. Indeed, we don’t know how long of a string may be inputted by the user! Further, we don’t know what garbage values may exist at the memory location.</p></li>
<li><p>Further, your code could be modified as follows. However, we have to pre-allocate a certain amount of memory for a string:</p>
<pre><code>// Using malloc

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    char *s = malloc(4);
    if (s == NULL)
    {
        return 1;
    }
    printf("s: ");
    scanf("%s", s);
    printf("s: %s\n", s);
    free(s);
    return 0;
}</code></pre>
<p>Notice that if a string that is four bytes is provided you <em>might</em> get an error.</p></li>
<li><p>Simplifying our code as follows, we can further understand this essential problem of pre-allocation:</p>
<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    char s[4];
    printf("s: ");
    scanf("%s", s);
    printf("s: %s\n", s);
}</code></pre>
<p>Notice that if we pre-allocate an array of size <code>4</code>, we can type <code>cat</code> and the program functions. However, a string larger than this <em>could</em> create an error.</p></li>
<li><p>Sometimes, the compiler or the system running it may allocate more memory than we indicate. Fundamentally, though, the above code is unsafe. We cannot trust that the user will input a string that fits into our pre-allocated memory.</p></li>
</ul>
</section>
<section id="file-io" class="level2">
<h2 class="anchored" data-anchor-id="file-io">File I/O</h2>
<ul>
<li><p>You can read from and manipulate files. While this topic will be discussed further in a future week, consider the following code for <code>phonebook.c</code>:</p>
<pre><code>// Saves names and numbers to a CSV file

#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    // Open CSV file
    FILE *file = fopen("phonebook.csv", "a");

    // Get name and number
    char *name = get_string("Name: ");
    char *number = get_string("Number: ");

    // Print to file
    fprintf(file, "%s,%s\n", name, number);

    // Close file
    fclose(file);
}</code></pre>
<p>Notice that this code uses pointers to access the file.</p></li>
<li><p>You can create a file called <code>phonebook.csv</code> in advance of running the above code or download <a href="https://raw.githubusercontent.com/SQ4007-2025/website/master/data/phonebook.csv?download">phonebook.csv</a>. After running the above program and inputting a name and phone number, you will notice that this data persists in your CSV file.</p></li>
</ul>
<p><a id="raw-url" href="https://raw.githubusercontent.com/SQ4007-2025/website/master/data/phonebook.csv">Download FILE</a></p>
<ul>
<li><p>If we want to ensure that <code>phonebook.csv</code> exists prior to running the program, we can modify our code as follows:</p>
<pre><code>// Saves names and numbers to a CSV file

#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    // Open CSV file
    FILE *file = fopen("phonebook.csv", "a");
    if (!file)
    {
        return 1;
    }

    // Get name and number
    char *name = get_string("Name: ");
    char *number = get_string("Number: ");

    // Print to file
    fprintf(file, "%s,%s\n", name, number);

    // Close file
    fclose(file);
}</code></pre>
<p>Notice that this program protects against a <code>NULL</code> pointer by invoking <code>return 1</code>.</p></li>
<li><p>We can implement our own copy program by typing <code>code cp.c</code> and writing code as follows:</p>
<pre><code>// Copies a file

#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

typedef uint8_t BYTE;

int main(int argc, char *argv[])
{
    FILE *src = fopen(argv[1], "rb");
    FILE *dst = fopen(argv[2], "wb");

    BYTE b;

    while (fread(&amp;b, sizeof(b), 1, src) != 0)
    {
        fwrite(&amp;b, sizeof(b), 1, dst);
    }

    fclose(dst);
    fclose(src);
}</code></pre>
<p>Notice that this file creates our own data type called a BYTE , which is the size of a uint8_t. Then, the file reads a <code>BYTE</code> and writes it to a file.</p></li>
<li><p>BMPs are also assortments of data that we can examine and manipulate. This week, you will be doing just that in your problem sets!</p></li>
</ul>
</section>
<section id="summing-up" class="level2">
<h2 class="anchored" data-anchor-id="summing-up">Summing Up</h2>
<p>In this lesson, you learned about pointers that provide you with the ability to access and manipulate data at specific memory locations. Specifically, we delved into…</p>
<ul>
<li>Pixel art</li>
<li>Hexadecimal</li>
<li>Memory</li>
<li>Pointers</li>
<li>Strings</li>
<li>Pointer Arithmetic</li>
<li>String Comparison</li>
<li>Copying</li>
<li>malloc and Valgrind</li>
<li>Garbage values</li>
<li>Swapping</li>
<li>Overflow</li>
<li><code>scanf</code></li>
<li>File I/O</li>
</ul>
<p>See you next time!</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/SQ4007-2025\.github\.io\/website\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© 2025 🐊 <a href="https://weharris.me">W. Edwin Harris</a></p>
</div>   
    <div class="nav-footer-center">
<p>📊 <a href="https://thestatisticslab.com">The Statistics Lab</a></p>
<div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/SQ4007-2025/website/edit/main/notes/notes_5.md" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/SQ4007-2025/website/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
<p>🚀 Built with <a href="https://quarto.org/">Quarto</a>.</p>
</div>
  </div>
</footer>




</body></html>